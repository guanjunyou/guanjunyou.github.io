<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Hexo
    </title>
    <meta name="description" content= 关竣佑的博客 >
    <meta name="keywords" content= Blog,Hexo,GuanJunyou,关竣佑 >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            Tulun
        </p>
        <hr>
    </div>
    <div class="post-content">
        <span id="more"></span>

<h1 id="关竣佑图论学习笔记"><a href="#关竣佑图论学习笔记" class="headerlink" title="关竣佑图论学习笔记"></a>关竣佑图论学习笔记</h1><p>[TOC]</p>
<h2 id="三种存图方法："><a href="#三种存图方法：" class="headerlink" title="三种存图方法："></a>三种存图方法：</h2><h3 id="1-邻接矩阵-2-邻接表-3-链式前向星"><a href="#1-邻接矩阵-2-邻接表-3-链式前向星" class="headerlink" title="1.邻接矩阵  2.邻接表  3.链式前向星"></a>1.邻接矩阵  2.邻接表  3.链式前向星</h3><h3 id="链式前向星：空间效率最高，没有浪费"><a href="#链式前向星：空间效率最高，没有浪费" class="headerlink" title="链式前向星：空间效率最高，没有浪费"></a>链式前向星：空间效率最高，没有浪费</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">1000005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,w,next;<span class="comment">//表示该边的下一个结点，权重，该边的上一个结点为起点所连的上一条边</span></span><br><span class="line">&#125;edge[num];</span><br><span class="line"><span class="keyword">int</span> head[num];<span class="comment">//记录每个结点所连的最后一条边</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        edge[i].next=<span class="number">-1</span>;</span><br><span class="line">        head[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历点i的所有邻居</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历所有边时，先找到该结点为起点的最后一条边，再往前找，直至遍历完该节点的所有边</strong></p>
<h2 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序：</h2><h3 id="类型1：确定字典序最小的拓扑排序：-（邻接矩阵存图）"><a href="#类型1：确定字典序最小的拓扑排序：-（邻接矩阵存图）" class="headerlink" title="*类型1：确定字典序最小的拓扑排序：* （邻接矩阵存图）"></a><em><strong>*类型1：确定字典序最小的拓扑排序：*</strong></em> （邻接矩阵存图）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span><span class="comment">//图论拓扑排序+优先队列hdu1285 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//hdu1285 DFS拓扑排序加优先队列</span></span><br><span class="line"><span class="keyword">bool</span> mp[<span class="number">517</span>][<span class="number">517</span>];</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">517</span>];<span class="comment">//记录入度 </span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;<span class="comment">//每次弹出最小值的优先队列 ,得到队伍编号最小的排名 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tuopu</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(in[i]==<span class="number">0</span>)</span><br><span class="line">			q.<span class="built_in">push</span>(i);<span class="comment">//把入度为0的压入队列 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(c!=n)<span class="comment">//没到尾 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			c++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout&lt;&lt;v&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!mp[v][i])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			in[i]--;<span class="comment">//入度减一 </span></span><br><span class="line">			<span class="keyword">if</span>(!in[i])</span><br><span class="line">				q.<span class="built_in">push</span>(i);<span class="comment">//把入度为0的压入队列 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,i,j;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mp));</span><br><span class="line">		<span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">		<span class="keyword">while</span>(m--)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">			mp[i][j]=<span class="number">1</span>;</span><br><span class="line">			in[j]++;	</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="built_in">tuopu</span>(n);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型2：按字典序从小到大输出所有拓扑排序（重要）"><a href="#类型2：按字典序从小到大输出所有拓扑排序（重要）" class="headerlink" title="*类型2：按字典序从小到大输出所有拓扑排序（重要）*"></a><em><strong>*类型2：按字典序从小到大输出所有拓扑排序（重要）*</strong></em></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span><span class="comment">//poj1270拓扑排序，邻接矩阵dfs实现，重要 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">30</span>][<span class="number">30</span>],in[<span class="number">30</span>],tp[<span class="number">30</span>],n;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getit</span><span class="params">(<span class="keyword">int</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">if</span>(s[i]==ch) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span><span class="comment">//输入 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(ch!=<span class="string">&#x27; &#x27;</span>) s[++n]=ch;</span><br><span class="line">	&#125;</span><br><span class="line">	s[++n]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">sort</span>(s+<span class="number">1</span>,s+n);</span><br><span class="line">	<span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">	<span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mp));</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)<span class="comment">//输入约束对 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())==<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span>(ch==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">int</span> u=<span class="built_in">getit</span>(ch);</span><br><span class="line">		<span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())==<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		<span class="keyword">int</span> v=<span class="built_in">getit</span>(ch);</span><br><span class="line">		mp[u][v]=<span class="number">1</span>;<span class="comment">//邻接矩阵储存 </span></span><br><span class="line">		in[v]++;<span class="comment">//入度增加	</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now==n) <span class="comment">//到结尾 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;s[tp[i]];<span class="comment">//输出拓扑序 </span></span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(in[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			in[i]=<span class="number">-1</span>;</span><br><span class="line">			tp[now]=<span class="number">1</span>;<span class="comment">//入度为0的在第一位 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">				<span class="keyword">if</span>(mp[i][j]) in[j]--;</span><br><span class="line">				<span class="comment">//把该结点的子节点入度递减 </span></span><br><span class="line">			<span class="built_in">dfs</span>(now+<span class="number">1</span>);</span><br><span class="line">			in[i]=<span class="number">0</span>;<span class="comment">//恢复现场 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">				<span class="keyword">if</span>(mp[i][j]) in[j]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">init</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="类型3：拓扑序找环，判断是否有环"><a href="#类型3：拓扑序找环，判断是否有环" class="headerlink" title="*类型3：拓扑序找环，判断是否有环*"></a><em><strong>*类型3：拓扑序找环，判断是否有环*</strong></em></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span><span class="comment">//hdu3342拓扑序找环 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> m[<span class="number">105</span>][<span class="number">105</span>];<span class="comment">//邻接矩阵储存</span></span><br><span class="line"><span class="keyword">int</span> master[<span class="number">105</span>];<span class="comment">//指向的徒弟的师傅数量（入度）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,M,u,v;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;M)!=EOF <span class="keyword">and</span> n)	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(master,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(master));</span><br><span class="line">		<span class="built_in">memset</span>(m,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(m));</span><br><span class="line">		<span class="keyword">while</span>(M--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">			<span class="keyword">if</span>(!m[u][v])</span><br><span class="line">			&#123;</span><br><span class="line">				m[u][v]=<span class="literal">true</span>;</span><br><span class="line">				++master[v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">bool</span> flag;</span><br><span class="line">		<span class="keyword">int</span> num=<span class="number">0</span>;<span class="comment">//人数</span></span><br><span class="line">		<span class="keyword">for</span>(;;)</span><br><span class="line">		&#123;</span><br><span class="line">			flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)<span class="comment">//找出master数量为0的人 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(master[u]==<span class="number">0</span>)&#123;</span><br><span class="line">					num++;</span><br><span class="line">					master[u]=<span class="number">-1</span>;</span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(m[u][v]) master[v]--;<span class="comment">//入度递减			 </span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag) <span class="keyword">break</span>;	</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(num==n) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="变式：判断有无环-反向建图"><a href="#变式：判断有无环-反向建图" class="headerlink" title="*变式：判断有无环+反向建图*"></a><em><strong>*变式：判断有无环+反向建图*</strong></em></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span><span class="comment">//拓扑排序+反向建图hdu2647</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">10005</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[M]; <span class="comment">//邻接表储存 </span></span><br><span class="line"><span class="keyword">int</span> num[M];</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> out[M];<span class="comment">//出度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(out[i]==<span class="number">0</span>)</span><br><span class="line">			q.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">		ans+=num[u];</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=g[u][i];</span><br><span class="line">			<span class="keyword">if</span>(--out[v]==<span class="number">0</span>)<span class="comment">//如果出度为0则放入队列且 钱数增加1 </span></span><br><span class="line">			&#123;</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">				num[v]=num[u]+<span class="number">1</span>;	</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt!=n)<span class="comment">//判断有无环，-1表示有环，1表示无环 </span></span><br><span class="line">		ans-=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			g[i].<span class="built_in">clear</span>();</span><br><span class="line">			out[i]=<span class="number">0</span>;</span><br><span class="line">			num[i]=<span class="number">888</span>;	</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">while</span>(m--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> u,v;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">			g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">			out[u]++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">toposort</span>()&lt;&lt;endl;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="欧拉路："><a href="#欧拉路：" class="headerlink" title="欧拉路："></a>欧拉路：</h2><table>
<thead>
<tr>
<th>存在欧拉路的充要条件</th>
<th><em><strong>*存在欧拉回路*</strong></em></th>
<th><em><strong>*存在欧拉路*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*无向图*</strong></em></td>
<td><em><strong>*每个结点都是偶点*</strong></em></td>
<td><em><strong>*只有2个奇点或每个结点都是偶点*</strong></em></td>
</tr>
<tr>
<td><em><strong>*有向图*</strong></em></td>
<td><em><strong>*每个点出度等于入度*</strong></em></td>
<td><em><strong>*只有两个点入度不等于出度且其中一个点入度-出度=1，另一个点出度-入度=1或每个点出度等于入度*</strong></em></td>
</tr>
</tbody></table>
<h3 id="类型1：无向图求欧拉回路-如果是有向图输出的是一个逆序的路径，可以用栈把逆序按正序打印出来）"><a href="#类型1：无向图求欧拉回路-如果是有向图输出的是一个逆序的路径，可以用栈把逆序按正序打印出来）" class="headerlink" title="类型1：无向图求欧拉回路  (如果是有向图输出的是一个逆序的路径，可以用栈把逆序按正序打印出来）"></a>类型1：无向图求欧拉回路  (如果是有向图输出的是一个逆序的路径，可以用栈把逆序按正序打印出来）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span><span class="comment">//uva10054 无向图求欧拉回路  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">55</span>][<span class="number">55</span>];<span class="comment">//邻接矩阵储存 </span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(d[i]%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//深搜打印欧拉回路模板 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=<span class="number">50</span>;v++)<span class="comment">//深搜u的所有邻居 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(g[u][v])</span><br><span class="line">		&#123;</span><br><span class="line">			g[u][v]--;g[v][u]--;<span class="comment">//可能有重边 </span></span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">			cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;u&lt;&lt;end;<span class="comment">//思考为什么在后面打印？ </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		g[u][v]++;</span><br><span class="line">		g[v][u]++;</span><br><span class="line">		d[v]++;d[u]++;<span class="comment">//度数 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">check</span>())</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;some beads may be lost&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">dfs</span>(u);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="判断负环："><a href="#判断负环：" class="headerlink" title="判断负环："></a>判断负环：</h2><h3 id="1-SPFA—BFS（会超时）-2-SPFA—DFS（高效）"><a href="#1-SPFA—BFS（会超时）-2-SPFA—DFS（高效）" class="headerlink" title="1.SPFA—BFS（会超时）  2.SPFA—DFS（高效）"></a>1.SPFA—BFS（会超时）  2.SPFA—DFS（高效）</h3><h3 id="SPFA—DFS-（基于链式前向星）："><a href="#SPFA—DFS-（基于链式前向星）：" class="headerlink" title="SPFA—DFS　（基于链式前向星）："></a>SPFA—DFS　（基于链式前向星）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs-spfa判断负环</span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> inf=<span class="number">0x7f7f7f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,u,v,w;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">2600</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2600</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">2600</span>];</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,w,next;</span><br><span class="line">&#125;edge[<span class="number">2600</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dis[i]=inf;</span><br><span class="line">	&#125;</span><br><span class="line">	dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		edge[i].next=<span class="number">-1</span>;</span><br><span class="line">		head[i]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[cnt].to=v;</span><br><span class="line">	edge[cnt].w=w;</span><br><span class="line">	edge[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(dis[u]+edge[i].w&lt;dis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[v])&#123;<span class="comment">//存在一个点再一条路上出现多次 </span></span><br><span class="line">				flag=<span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				dis[v]=dis[u]+edge[i].w;</span><br><span class="line">				<span class="built_in">spfa</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[u]=<span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		flag=<span class="literal">false</span>;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="keyword">while</span>(m--)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">			<span class="built_in">addedge</span>(u,v,w);</span><br><span class="line">			<span class="built_in">addedge</span>(v,u,w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(k--)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">			<span class="built_in">addedge</span>(u,v,-w);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强连通问题：求强连通分量（SCC）"><a href="#强连通问题：求强连通分量（SCC）" class="headerlink" title="强连通问题：求强连通分量（SCC）"></a>强连通问题：求强连通分量（SCC）</h2><p><strong>两个点可互相到达</strong></p>
<h3 id="Kosaraju算法：运用反图技术"><a href="#Kosaraju算法：运用反图技术" class="headerlink" title="Kosaraju算法：运用反图技术"></a>Kosaraju算法：运用反图技术</h3><h4 id="裸题：hdu1269"><a href="#裸题：hdu1269" class="headerlink" title="裸题：hdu1269"></a>裸题：hdu1269</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//求强联通分量的Kosaraju算法</span></span><br><span class="line"><span class="comment">//hdu1269</span></span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">int</span> num=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;G[num],rG[num];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; S;<span class="comment">//存第一次dfs1的结果，标记点的顺序</span></span><br><span class="line"><span class="keyword">int</span> vis[num],sccno[num],cnt;<span class="comment">//cnt记录强连通分量的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[u]) <span class="keyword">return</span>;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs1</span>(G[u][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	S.<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sccno[u]) <span class="keyword">return</span>;</span><br><span class="line">	sccno[u]=cnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rG[u].<span class="built_in">size</span>();i++) <span class="built_in">dfs2</span>(rG[u][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	S.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(sccno,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sccno));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">dfs1</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!sccno[S[i]])</span><br><span class="line">		&#123;cnt++;<span class="built_in">dfs2</span>(S[i]);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">	&#123;	<span class="keyword">int</span> u,v;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			G[i].<span class="built_in">clear</span>();rG[i].<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">			G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">			rG[v].<span class="built_in">push_back</span>(u);<span class="comment">//存反图 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">kosaraju</span>(n);</span><br><span class="line">		<span class="keyword">if</span>(cnt==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="Tarjan算法：一次性把所有SCC都挖出来-用栈来处理"><a href="#Tarjan算法：一次性把所有SCC都挖出来-用栈来处理" class="headerlink" title="Tarjan算法：一次性把所有SCC都挖出来  用栈来处理"></a>Tarjan算法：一次性把所有SCC都挖出来  用栈来处理</h3><h4 id="裸题：hdu1269-1"><a href="#裸题：hdu1269-1" class="headerlink" title="裸题：hdu1269"></a>裸题：hdu1269</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span><span class="comment">//Tarjan算法求强连通分量 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> low[N],num[N],dfn;</span><br><span class="line"><span class="keyword">int</span> sccno[N];<span class="comment">//表示该点处于的SCC </span></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	S.<span class="built_in">push</span>(u);</span><br><span class="line">	low[u]=num[u]=++dfn;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=G[u][i];</span><br><span class="line">		<span class="keyword">if</span>(!num[v])&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[v],low[u]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!sccno[v])<span class="comment">//若v还在栈里</span></span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],num[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[u]==num[u])&#123;<span class="comment">//栈底的点是SCC的祖先它的low=num </span></span><br><span class="line">        <span class="comment">//遍历完后若还没能通过子孙返回更早的时间点则u为SCC的祖先</span></span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> v=S.<span class="built_in">top</span>();</span><br><span class="line">			S.<span class="built_in">pop</span>();</span><br><span class="line">			sccno[v]=cnt;</span><br><span class="line">			<span class="keyword">if</span>(u==v) <span class="keyword">break</span>;<span class="comment">//栈底的点是SCC的祖先 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt=dfn=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sccno,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sccno));</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">	<span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(low));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(!num[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,u,v;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m),n!=<span class="number">0</span>||m!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) G[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">			G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Tarjan</span>(n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,cnt==<span class="number">1</span>?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变式一：Tarjan缩点，求到每个缩点的最小代价和（非AC代码）"><a href="#变式一：Tarjan缩点，求到每个缩点的最小代价和（非AC代码）" class="headerlink" title="变式一：Tarjan缩点，求到每个缩点的最小代价和（非AC代码）"></a>变式一：Tarjan缩点，求到每个缩点的最小代价和（非AC代码）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span><span class="comment">//hdu1827</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> low[N],num[N],dfn,w[N];<span class="comment">//dfn是记录进入递归的顺序 </span></span><br><span class="line"><span class="keyword">int</span> M[N];</span><br><span class="line"><span class="keyword">int</span> sccno[N];</span><br><span class="line"><span class="keyword">int</span> in[N];</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	S.<span class="built_in">push</span>(u);</span><br><span class="line">	low[u]=num[u]=++dfn;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=G[u][i];</span><br><span class="line">		<span class="keyword">if</span>(!num[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[v]);	</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!sccno[v])</span><br><span class="line">		&#123;</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],num[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[u]==num[u])</span><br><span class="line">	&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		M[cnt]=<span class="number">0x7f7f7f</span>;<span class="comment">//记录每个新的缩点的最小花费 </span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=S.<span class="built_in">top</span>();</span><br><span class="line">			S.<span class="built_in">pop</span>();</span><br><span class="line">			sccno[v]=cnt;</span><br><span class="line">			M[cnt]=<span class="built_in">min</span>(M[cnt],w[v]);</span><br><span class="line">			<span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt=dfn=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sccno,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sccno));</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">	<span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(low));</span><br><span class="line">	<span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!num[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Tarjan</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> v=G[i][j];</span><br><span class="line">			<span class="keyword">if</span>(sccno[i]!=sccno[v])</span><br><span class="line">				in[sccno[v]]++;<span class="comment">//该缩点入度不为0 </span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			sum1++;</span><br><span class="line">			sum2+=M[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;sum2&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变式二：Tarjan-贪心-求每个缩点的最小入边权值和（TLE）"><a href="#变式二：Tarjan-贪心-求每个缩点的最小入边权值和（TLE）" class="headerlink" title="变式二：Tarjan+贪心 求每个缩点的最小入边权值和（TLE）"></a>变式二：Tarjan+贪心 求每个缩点的最小入边权值和（TLE）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//hdu3072 Tarjan算法求最小代价</span></span><br><span class="line"><span class="keyword">int</span> cnt,dfn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> num[N],low[N],M[N],sccno[N];</span><br><span class="line"><span class="keyword">int</span> W[<span class="number">100010</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;G[N];</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="keyword">bool</span> flag[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">bool</span> Flag[<span class="number">100010</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	S.<span class="built_in">push</span>(u);</span><br><span class="line">	low[u]=num[u]=++dfn;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=G[u][i];</span><br><span class="line">		<span class="keyword">if</span>(!num[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!sccno[v])</span><br><span class="line">		&#123;</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],num[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[u]==num[u])&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=S.<span class="built_in">top</span>();</span><br><span class="line">			S.<span class="built_in">pop</span>();</span><br><span class="line">			sccno[v]=cnt;</span><br><span class="line">			<span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sccno,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sccno));</span><br><span class="line">	<span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(low));</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!num[i])	</span><br><span class="line">		<span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) G[i].<span class="built_in">clear</span>();<span class="comment">//不要忘</span></span><br><span class="line">		<span class="built_in">memset</span>(W,<span class="number">0x7f7f7f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(W));</span><br><span class="line">		<span class="built_in">memset</span>(M,<span class="number">0x7f7f7f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(M));</span><br><span class="line">		<span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(flag));<span class="comment">//防止有些点没有入度标志为0</span></span><br><span class="line">		<span class="built_in">memset</span>(Flag,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Flag));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> u,v,w;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">			G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">			M[v]=<span class="built_in">min</span>(M[v],w);<span class="comment">//记录每个点最小入边权值</span></span><br><span class="line">			flag[v]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Tarjan</span>(n);</span><br><span class="line">		<span class="comment">//for(int i=0;i&lt;n;i++)</span></span><br><span class="line">			<span class="comment">//cout&lt;&lt;flag[i]&lt;&lt;&quot; &quot;&lt;&lt;sccno[i]&lt;&lt;endl;</span></span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G[i].<span class="built_in">size</span>();j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> v=G[i][j];</span><br><span class="line">				<span class="keyword">if</span>(sccno[i]!=sccno[v])<span class="comment">//位于两个不同的缩点 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;endl;</span></span><br><span class="line">					<span class="keyword">if</span>(flag[v]==<span class="number">1</span>)&#123;</span><br><span class="line">					W[sccno[v]]=<span class="built_in">min</span>(M[v],W[sccno[v]]);<span class="comment">//求每个缩点最小入边权值 </span></span><br><span class="line">					Flag[sccno[v]]=<span class="number">1</span>;&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Flag[i]==<span class="number">1</span>)</span><br><span class="line">			sum+=W[i];<span class="comment">////求每个缩点最小入边权值和 </span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="变式三：给定有向图至少添加多少条边才能成为强连通图？（非AC）"><a href="#变式三：给定有向图至少添加多少条边才能成为强连通图？（非AC）" class="headerlink" title="变式三：给定有向图至少添加多少条边才能成为强连通图？（非AC）"></a>变式三：给定有向图至少添加多少条边才能成为强连通图？（非AC）</h4><p><strong>思路：缩点之后MAX（出度为0的点个数，入度为0的点个数）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//hdu3836 一个有向图要添加多少条边才能变成强连通图</span></span><br><span class="line"><span class="comment">//Tarjan缩点 </span></span><br><span class="line"><span class="keyword">int</span> cnt,dfn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> sccno[N], num[N],low[N];</span><br><span class="line"><span class="keyword">int</span> IN[<span class="number">50010</span>],OUT[<span class="number">50010</span>];<span class="comment">//缩点后每个点的出度和入度 </span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	S.<span class="built_in">push</span>(u);</span><br><span class="line">	low[u]=num[u]=++dfn;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=G[u][i];</span><br><span class="line">		<span class="keyword">if</span>(!num[v])&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!sccno[v])&#123;</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],num[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[u]==num[u])&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=S.<span class="built_in">top</span>();</span><br><span class="line">			S.<span class="built_in">pop</span>();</span><br><span class="line">			sccno[v]=cnt;</span><br><span class="line">			<span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt=dfn=<span class="number">0</span>; </span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">	<span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(low));</span><br><span class="line">	<span class="built_in">memset</span>(sccno,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sccno));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!num[i])</span><br><span class="line">		<span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v;</span><br><span class="line">		<span class="built_in">memset</span>(IN,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(IN));</span><br><span class="line">		<span class="built_in">memset</span>(OUT,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(OUT));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">			G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Tarjan</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G[i].<span class="built_in">size</span>();j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> v=G[i][j];</span><br><span class="line">				<span class="keyword">if</span>(sccno[i]!=sccno[v])</span><br><span class="line">				&#123;</span><br><span class="line">					IN[sccno[v]]++;OUT[sccno[i]]++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;<span class="comment">//记录出度为0和入度为0的点分别有多少个 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(IN[i]==<span class="number">0</span>) sum1++;</span><br><span class="line">			<span class="keyword">if</span>(OUT[i]==<span class="number">0</span>) sum2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="built_in">max</span>(sum1,sum2)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="有向图dfs判断连通性且判断是否存在"><a href="#有向图dfs判断连通性且判断是否存在" class="headerlink" title="有向图dfs判断连通性且判断是否存在"></a>有向图dfs判断连通性且判断是否存在</h2><h2 id="欧拉路：-1"><a href="#欧拉路：-1" class="headerlink" title="欧拉路："></a>欧拉路：</h2><h2 id="最短路："><a href="#最短路：" class="headerlink" title="最短路："></a>最短路：</h2><h3 id="类型1：基于链式前向星的SPFA-判断负环："><a href="#类型1：基于链式前向星的SPFA-判断负环：" class="headerlink" title="类型1：基于链式前向星的SPFA+判断负环："></a><em><strong>类型1：基于链式前向星的SPFA+判断负环：</strong></em></h3><p><strong>适合大图使用，但是不稳定，可能有极端数据卡时间复杂度，求最短路首选dijkstra</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基于链式前向星的bfs-SPFA 判断负环+最短路</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,w,next;<span class="comment">//边的相邻结点，边的权重，边的from点为起点的上一条边 </span></span><br><span class="line">&#125;edge[num];</span><br><span class="line"><span class="keyword">int</span> head[num];</span><br><span class="line"><span class="keyword">int</span> dis[num];<span class="comment">//记录所有结点到起点的距离</span></span><br><span class="line"><span class="keyword">bool</span> inq[num];<span class="comment">//表示结点是否在队列中</span></span><br><span class="line"><span class="keyword">int</span> neg[num];<span class="comment">//判断负环</span></span><br><span class="line"><span class="keyword">int</span> pre[num];<span class="comment">//记录前驱结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_path</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s==t) &#123;cout&lt;&lt;s; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="built_in">print_path</span>(s,pre[t]);</span><br><span class="line">	cout&lt;&lt;t;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">		edge[i].next=<span class="number">-1</span>;</span><br><span class="line">		head[i]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[cnt].to=v;</span><br><span class="line">	edge[cnt].w=w;</span><br><span class="line">	edge[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">	cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(neg,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(neg));</span><br><span class="line">	neg[s]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dis[s]=inf;inq[i]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	inq[s]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">		inq[u]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[u]+w&lt;dis[v])</span><br><span class="line">			&#123;</span><br><span class="line">				dis[v]=dis[v]+w;</span><br><span class="line">				pre[v]=u;</span><br><span class="line">				<span class="keyword">if</span>(!inq[v])&#123;</span><br><span class="line">					inq[v]=<span class="literal">true</span>;</span><br><span class="line">					Q.<span class="built_in">push</span>(v);</span><br><span class="line">					neg[v]++;</span><br><span class="line">					<span class="keyword">if</span>(neg[v]&gt;n) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//出现负环 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dis[n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">addedge</span>(u,v,w);</span><br><span class="line">		<span class="built_in">addedge</span>(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类型2：Bellman-Ford算法："><a href="#类型2：Bellman-Ford算法：" class="headerlink" title="*类型2：Bellman-Ford算法：*"></a><em><strong>*类型2：Bellman-Ford算法：*</strong></em></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//bellman-ford最短路</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">105</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w;<span class="comment">//边：起点，终点，权值 </span></span><br><span class="line">&#125;e[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">int</span> pre[num];</span><br><span class="line"><span class="comment">//记录前驱结点pre[x]=y，x的前一个结点是y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_path</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s==t) &#123;cout&lt;&lt;s;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="built_in">print_path</span>(s,pre[t]);</span><br><span class="line">	cout&lt;&lt;t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bellman</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s=<span class="number">1</span>;<span class="comment">//定义起点</span></span><br><span class="line">	<span class="keyword">int</span> d[num];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//一共有n轮操作</span></span><br><span class="line">		d[i]=inf;</span><br><span class="line">	d[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x=e[i].u,y=e[i].v;</span><br><span class="line">			<span class="keyword">if</span>(d[x]&gt;d[y]+e[i].w)</span><br><span class="line">			&#123;</span><br><span class="line">				d[x]=d[y]+e[i].w;</span><br><span class="line">				pre[x]=y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	cout&lt;&lt;d[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		cnt=<span class="number">0</span>;<span class="comment">//记录边的数量</span></span><br><span class="line">		<span class="keyword">while</span>(m--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> a,b,c;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">			e[cnt].u=a;e[cnt].v=b;e[cnt].w=c;cnt++;</span><br><span class="line">			e[cnt].u=b;e[cnt].v=a;e[cnt].w=c;cnt++;	</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="built_in">bellman</span>();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="类型3：Dijkstra算法最短路"><a href="#类型3：Dijkstra算法最短路" class="headerlink" title="*类型3：Dijkstra算法最短路*"></a><em><strong>*类型3：Dijkstra算法最短路*</strong></em></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//hdu2544 Dijkstra最短路径 邻接表+优先队列</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  inf=<span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">105</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,w;</span><br><span class="line">	<span class="built_in">edge</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)&#123;</span><br><span class="line">		from=a;to=b;w=c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;e[num];<span class="comment">//用于存图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id,n_dis;</span><br><span class="line">	<span class="built_in">s_node</span>(<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><br><span class="line">	&#123;</span><br><span class="line">		id=b;n_dis=c;<span class="comment">//id:结点，n_dis:这个结点到起点的距离 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(s_node a,s_node b)  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a.n_dis&gt;b.n_dis; <span class="comment">//注意这里是输出小的在队首（判断和sort相反！） </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> pre[num];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_path</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span><span class="comment">//打印从s到t的路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s==t) &#123;cout&lt;&lt;s; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="built_in">print_path</span>(s,pre[t]);</span><br><span class="line">	cout&lt;&lt;t;	</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> dis[num];<span class="comment">//记录所有结点到起点的距离</span></span><br><span class="line">	<span class="keyword">bool</span> done[num];<span class="comment">//表示到结点i的最短路径已经找到了 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dis[i]=inf;done[i]=<span class="literal">false</span>;	</span><br><span class="line">	&#125; </span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;s_node&gt; Q;<span class="comment">//优先队列，存结点信息</span></span><br><span class="line">	Q.<span class="built_in">push</span>(<span class="built_in">s_node</span>(s,dis[s]));</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		s_node u=Q.<span class="built_in">top</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(done[u.id])</span><br><span class="line">			<span class="keyword">continue</span>;<span class="comment">//丢弃已经找到最短路径的结点，即集合A中的点</span></span><br><span class="line">		done[u.id]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u.id].<span class="built_in">size</span>();i++)<span class="comment">//检查结点u的所有邻居边</span></span><br><span class="line">		&#123;</span><br><span class="line">			edge y=e[u.id][i];<span class="comment">//u.id 的第i个邻居是y.to</span></span><br><span class="line">			<span class="keyword">if</span>(done[y.to]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[y.to]&gt;y.w+u.n_dis)&#123;</span><br><span class="line">				dis[y.to]=y.w+u.n_dis;</span><br><span class="line">				Q.<span class="built_in">push</span>(<span class="built_in">s_node</span>(y.to,dis[y.to]));</span><br><span class="line">				pre[y.to]=u.id;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;	</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;dis[n]&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//print_path(s,n);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+</span><br><span class="line">		&#123;</span><br><span class="line">			e[i].<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(m--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> a,b,c;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">			e[a].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(a,b,c));</span><br><span class="line">			e[b].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(b,a,c)); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dijkstra</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h2><h3 id="最小生成树模板："><a href="#最小生成树模板：" class="headerlink" title="最小生成树模板："></a>最小生成树模板：</h3><p>kruskal用于稀疏图  prim用于稠密图</p>
<h4 id="Kruskal算法：加并查集判环"><a href="#Kruskal算法：加并查集判环" class="headerlink" title="Kruskal算法：加并查集判环"></a>Kruskal算法：加并查集判环</h4><p>对边进行排序，依次把最短的边加入到T中并判环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span><span class="comment">//hdu1102right </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y, w;</span><br><span class="line">&#125;edge[<span class="number">5055</span>];</span><br><span class="line"><span class="keyword">int</span> parent[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(e a, e b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		parent[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = x;</span><br><span class="line">	<span class="keyword">while</span>(r!=parent[r])&#123;</span><br><span class="line">		r = parent[r];</span><br><span class="line">	&#125;<span class="comment">//一直找到根节点 </span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">while</span>(x!=r)&#123;</span><br><span class="line">		temp = x;</span><br><span class="line">		x = parent[x];<span class="comment">//x改为x的父结点 </span></span><br><span class="line">		parent[temp] = r;<span class="comment">//把当前结点的集改为根节点 </span></span><br><span class="line">	&#125;<span class="comment">//把路径上元素的集改为根节点 </span></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;<span class="comment">//并查集路径压缩非递归代码 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">initSet</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = <span class="built_in">find</span>(edge[i].x);</span><br><span class="line">		<span class="keyword">int</span> y = <span class="built_in">find</span>(edge[i].y);</span><br><span class="line">		<span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">			count++;</span><br><span class="line">			parent[x] = y;</span><br><span class="line">			sum+= edge[i].w;</span><br><span class="line">			<span class="comment">//if(count==n-1)&#123;</span></span><br><span class="line">			<span class="comment">//	break;</span></span><br><span class="line">			<span class="comment">//&#125;n个点有n-1条边</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i , j , t, weight;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">		m = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;weight);</span><br><span class="line">				<span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">					edge[m].x = i;</span><br><span class="line">					edge[m].y = j;</span><br><span class="line">					edge[m].w = weight;</span><br><span class="line">					c[i][j] = m++;<span class="comment">//m是边的个数 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;t;</span><br><span class="line">		<span class="comment">//m=n*(n-1)/2;也是一样的 </span></span><br><span class="line">		<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">			<span class="keyword">int</span> a, b;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">			<span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">				<span class="built_in">swap</span>(a, b);</span><br><span class="line">			&#125;</span><br><span class="line">			edge[c[a][b]].w= <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(edge, edge+m, comp);</span><br><span class="line">		<span class="built_in">kruskal</span>();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//hdu1102最小生成树  WA代码 </span></span><br><span class="line"><span class="keyword">int</span> n,q,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> c[num][num];</span><br><span class="line"><span class="keyword">int</span> S[num];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;e[num*num];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//并查集判环 没有路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> S[u]==u?u:<span class="built_in">find</span>(S[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) S[i]=i;</span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> b=<span class="built_in">find</span>(e[i].u);</span><br><span class="line">		<span class="keyword">int</span> c=<span class="built_in">find</span>(e[i].v);</span><br><span class="line">		<span class="keyword">if</span>(b==c) <span class="keyword">continue</span>;</span><br><span class="line">		S[c]=b;</span><br><span class="line">		ans+=e[i].w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">	m=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;w;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">				e[m].u=i;</span><br><span class="line">				e[m].v=j;</span><br><span class="line">				e[m].w=w;</span><br><span class="line">				c[i][j]=m++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//m=n*(n-1)/2;</span></span><br><span class="line">	cin&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(u&gt;v)&#123;</span><br><span class="line">			<span class="built_in">swap</span>(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">		e[c[u][v]].w=<span class="number">0</span>;<span class="comment">//已经开通 </span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">kruskal</span>()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prim算法：邻接矩阵存图"><a href="#prim算法：邻接矩阵存图" class="headerlink" title="prim算法：邻接矩阵存图"></a>prim算法：邻接矩阵存图</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//hdu1102最小生成树prim算法 邻接表存图 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,inf=<span class="number">0x7f7f7f</span>;</span><br><span class="line"><span class="keyword">int</span> cost[num][num];<span class="comment">//uv边的权值</span></span><br><span class="line"><span class="keyword">int</span> mincost[num];<span class="comment">//从集合X出发的边到每个顶点的最小权值 </span></span><br><span class="line"><span class="keyword">bool</span> used[num];<span class="comment">//顶点i是否包含在X中 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mincost[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">		&#123;<span class="comment">//从不属于X的顶点中选取X到其权值最小的顶点 </span></span><br><span class="line">			<span class="keyword">if</span>(!used[u]&amp;&amp;(v==<span class="number">-1</span>||mincost[u]&lt;mincost[v])) </span><br><span class="line">				v=u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(v==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">		used[v]=<span class="literal">true</span>;</span><br><span class="line">		res+=mincost[v];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">			mincost[u]=<span class="built_in">min</span>(mincost[u],cost[v][u]);<span class="comment">//更新 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(cost,inf,<span class="built_in"><span class="keyword">sizeof</span></span>(cost));</span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(used));</span><br><span class="line">		<span class="built_in">memset</span>(mincost,inf,<span class="built_in"><span class="keyword">sizeof</span></span>(mincost));</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*(n<span class="number">-1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> u,v,w;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">			cost[u][v]=w;</span><br><span class="line">			cost[v][u]=w;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">prim</span>()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大生成树问题：Kruskal算法"><a href="#最大生成树问题：Kruskal算法" class="headerlink" title="最大生成树问题：Kruskal算法"></a>最大生成树问题：Kruskal算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//最大生成树poj2377  AC代码 </span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> S[num];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;e[<span class="number">40010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w&gt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> S[u]==u?u:<span class="built_in">find</span>(S[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		S[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(e,e+m,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> b=<span class="built_in">find</span>(e[i].u);</span><br><span class="line">		<span class="keyword">int</span> c=<span class="built_in">find</span>(e[i].v);</span><br><span class="line">		<span class="keyword">if</span>(b==c) <span class="keyword">continue</span>;</span><br><span class="line">		S[c]=b;</span><br><span class="line">		cnt++;</span><br><span class="line">		ans+=e[i].w;</span><br><span class="line">		<span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">	 &#125; </span><br><span class="line">	<span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">return</span> ans;<span class="comment">//重点 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v,w;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		e[i].u=u;e[i].v=v;e[i].w=w;</span><br><span class="line">	    &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">kruskal</span>()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络流问题："><a href="#网络流问题：" class="headerlink" title="网络流问题："></a>网络流问题：</h2><h3 id="最大流问题：Ford-Fullkerson方法"><a href="#最大流问题：Ford-Fullkerson方法" class="headerlink" title="最大流问题：Ford-Fullkerson方法"></a>最大流问题：Ford-Fullkerson方法</h3><h4 id="Edmonds-Karp算法（EK）："><a href="#Edmonds-Karp算法（EK）：" class="headerlink" title="Edmonds-Karp算法（EK）："></a>Edmonds-Karp算法（EK）：</h4><p>由于适用规模小所以用邻接矩阵存图</p>
<p>１.找到一条增广路２.找到瓶颈正向路径减少ｆｌｏｗ，反向路径增加ｆｌｏｗ３.直到找不到增广路</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//Edmonds-Karp算法 最大流问题</span></span><br><span class="line"><span class="comment">//hdu1532</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,G[maxn][maxn],pre[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow[maxn];</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">	flow[s]=inf;pre[s]=<span class="number">0</span>;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(u==t) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i!=s&amp;&amp;G[u][i]&gt;<span class="number">0</span>&amp;&amp;pre[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">				pre[i]=u;</span><br><span class="line">				Q.<span class="built_in">push</span>(i);</span><br><span class="line">				flow[i]=<span class="built_in">min</span>(flow[u],G[u][i]);<span class="comment">//更新结点流量 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pre[t]==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没有找到新的增广路 </span></span><br><span class="line">	<span class="keyword">return</span> flow[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Maxflow=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> flow=<span class="built_in">bfs</span>(s,t);</span><br><span class="line">		<span class="comment">//执行一次BFS找到一条路径返回路径的流量</span></span><br><span class="line">		<span class="keyword">if</span>(flow==<span class="number">-1</span>) <span class="keyword">break</span>;<span class="comment">//没有找到新的增广路</span></span><br><span class="line">		<span class="keyword">int</span> cur=t;<span class="comment">//</span></span><br><span class="line">		<span class="keyword">while</span>(cur!=s)<span class="comment">//一直沿路径回溯到起点 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> father=pre[cur];<span class="comment">//pre记录路径上前一个点 </span></span><br><span class="line">			G[father][cur]-=flow;<span class="comment">//更新残留网络，正向减 </span></span><br><span class="line">			G[cur][father]+=flow;</span><br><span class="line">			cur=father;</span><br><span class="line">		&#125; </span><br><span class="line">		Maxflow+=flow; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">memset</span>(G,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(G));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> u,v,w;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">			G[u][v]+=w;<span class="comment">//可能有重边 </span></span><br><span class="line">		&#125;	</span><br><span class="line">		cout&lt;&lt;<span class="built_in">maxflow</span>(<span class="number">1</span>,m)&lt;&lt;endl;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>EK算法效率不高，竞赛中一般用ISAP算法</strong></p>
<h4 id="最大流建模："><a href="#最大流建模：" class="headerlink" title="最大流建模："></a>最大流建模：</h4><p><strong>一  ， 无向图转换为有向图  二，多个源点s和汇点t：添加超级源点和超级汇点，从s到每个源点都有一条边，从每个汇点都连一个边到t</strong></p>
<h3 id="最小割问题："><a href="#最小割问题：" class="headerlink" title="最小割问题："></a>最小割问题：</h3><h3 id="最小费用最大流："><a href="#最小费用最大流：" class="headerlink" title="最小费用最大流："></a>最小费用最大流：</h3><p><strong>从零流开始，每次增加一个最小费用路径，经过多次增广，直到无法再增加路径。</strong></p>
<p><strong>最大流问题和最短路径问题结合。</strong></p>
<p><strong>由于存在负边（不是负环）所以只能用Ford-Fulkerson方法+SPFA算法</strong></p>
<p>下面这道题是poj2135 把每条边的流量设为1每条边只能用一次，在图中添加一个超级源点和超级汇点</p>
<p>无向图变成四个边：首先分成有向边(u,v),(v,u);</p>
<p>有向边(u,v)变成一个正向的费用为cost ,容量为capacity的边，以及一个反向的费用为-cost,容量为0的边。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//poj2135最小费用最大流</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N],pre[N],preve[N];<span class="comment">//dis[i]记录起点到i的最短距离</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,cost,capacity,rev;</span><br><span class="line">	<span class="comment">//表示下一个点，费用，容量，前驱结点 </span></span><br><span class="line">	<span class="built_in">edge</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)&#123;</span><br><span class="line">		to=a;cost=b;capacity=c;rev=d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; <span class="comment">//邻接表存图</span></span><br><span class="line">vector&lt;edge&gt; e[N];<span class="comment">//存第i个结点连接的所有边 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cost,<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">	e[from].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(to,cost,capacity,e[to].<span class="built_in">size</span>()));</span><br><span class="line">	e[to].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(from,-cost,<span class="number">0</span>,e[from].<span class="built_in">size</span>()<span class="number">-1</span>));<span class="comment">//把一个有向边再分为两个 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> inq[N];</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		dis[i]=inf;inq[i]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	inq[s]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		inq[u]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].<span class="built_in">size</span>();i++)</span><br><span class="line">			<span class="keyword">if</span>(e[u][i].capacity&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">int</span> v=e[u][i].to,cost=e[u][i].cost;</span><br><span class="line">				<span class="keyword">if</span>(dis[u]+cost&lt;dis[v])&#123;</span><br><span class="line">					dis[v]=dis[u]+cost;</span><br><span class="line">					pre[v]=u;<span class="comment">//v的前驱结点是u </span></span><br><span class="line">					preve[v]=i;<span class="comment">//u的第i个边连接v点</span></span><br><span class="line">					<span class="keyword">if</span>(!inq[v])&#123;</span><br><span class="line">						inq[v]=<span class="literal">true</span>;</span><br><span class="line">						Q.<span class="built_in">push</span>(v);</span><br><span class="line">					&#125; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[t]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mincost</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cost=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">spfa</span>(s,t,cnt))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=t,flow=inf;<span class="comment">//每次增加的流量 </span></span><br><span class="line">		<span class="keyword">while</span>(pre[v]!=<span class="number">-1</span>)&#123;<span class="comment">//回溯整个路径计算路径的流 </span></span><br><span class="line">			<span class="keyword">int</span> u=pre[v],i=preve[v];</span><br><span class="line">			<span class="comment">//u是v的前驱结点，u的第i个边连接v</span></span><br><span class="line">			flow=<span class="built_in">min</span>(flow,e[u][i].capacity);</span><br><span class="line">			<span class="comment">//所有边的最小容量是这条路的流</span></span><br><span class="line">			v=u; </span><br><span class="line">		&#125;</span><br><span class="line">		v=t;</span><br><span class="line">		<span class="keyword">while</span>(pre[v]!=<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> u=pre[v],i=preve[v];</span><br><span class="line">			e[u][i].capacity-=flow;</span><br><span class="line">			e[v][e[u][i].rev].capacity+=flow;</span><br><span class="line">			v=u;</span><br><span class="line">		&#125;</span><br><span class="line">		cost+=dis[t]*flow;<span class="comment">//费用累加，如果程序需要输出最大流， </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cost; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) e[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> u,v,w;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">			<span class="built_in">addedge</span>(u,v,w,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">addedge</span>(v,u,w,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> s=n+<span class="number">1</span>,t=n+<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">addedge</span>(s,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">addedge</span>(n,t,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">mincost</span>(s,t,n+<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大流问题变式："><a href="#最大流问题变式：" class="headerlink" title="最大流问题变式："></a>最大流问题变式：</h3><h4 id="变式一：多源点多汇点"><a href="#变式一：多源点多汇点" class="headerlink" title="变式一：多源点多汇点"></a>变式一：多源点多汇点</h4><p><strong>添加超级源点t和超级汇点s，从s向每个源点连一个容量为对应最大流出容量的边，从每个汇点向t连一条容量为对应最大容量的边。</strong></p>
<h4 id="变式二：无向图"><a href="#变式二：无向图" class="headerlink" title="变式二：无向图"></a>变式二：无向图</h4><p><strong>当作有向图两个方向的边容量相同</strong></p>
<h4 id="变式三：顶点上也有容量限制的情况"><a href="#变式三：顶点上也有容量限制的情况" class="headerlink" title="变式三：顶点上也有容量限制的情况"></a>变式三：顶点上也有容量限制的情况</h4><p>**把每个顶点拆成两个，从入顶点到出顶点连一条顶点容量的边</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: Your Name | Theme By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
